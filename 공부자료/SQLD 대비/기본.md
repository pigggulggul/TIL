# SQLD 대비

### 엔터티

객체, 실체, 정보를 저장할 수 잇는 어떤 것.

- 예를 들어 ‘학생’이라는 엔터티는 학번, 이름, 이수학점, 등록일자, 생일, 주소, 전화번호, 전공 등의 속성으로 특징지어질 수 있다.
- 과목은 수학, 영어, 국어가 존재할 수 있는데 수학, 영어, 국어는 각각이 과목이라는 엔터티의 인스턴스들

(자바에서 클래스와 오브젝트의 관계와 비슷함)

### 엔터티 특징 :

- 해당 업무게 필요하고 관리하고자 하는 정보
- 식별이 가능해야함
- 인스턴스의 집합 (2개 이상) 이용
- 속성이 있어야함
- 1개 이상의 엔터티와 관계가 있어야함

### 엔티티의 분류

### 유무형에 따라

**유형엔터티**(Tangible Entity)는 물리적인 형태가 있고 안정적이며 지속적으로 활용되는 엔터티로 업무로부터 엔터티를 구분하기가 가장 용이하다. 예를 들면, 사원, 물품, 강사 등이 이에 해당된다. **개념엔터티**(Conceptual Entity)는 물리적인 형태는 존재하지 않고 관리해야 할 개념적 정보로 구분이 되는 엔터티로 조직, 보험상품 등이 이에 해당된다.

사건 엔터티(Event Entity)는 업무를 수행함에 따라 발생되는 엔터티로서 비교적 발생량이 많으며 각종 통계자료에 이용될 수 있다. 주문, 청구, 미납 등이 이에 해당된다. V-엔티티

### 발생시점에 따라

**기본엔터티**란 그 업무에 원래 존재하는 정보로서 다른 엔터티와 관계에 의해 생성되지 않고 독립적으로 생성이 가능, 자신은 타 엔터티의 부모의 역할을 하게 된다. 다른 엔터티로부터 주식별자를 상속받지 않고 자신의 고유한 주식별자를 가지게 된다. 예를 들어 사원, 부서, 고객, 상품, 자재 .

**중심엔터티**란 기본엔터티로부터 발생,그 업무에 있어서 중심적인 역할. 데이터의 양이 많이 발생. 다른 엔터티와의 관계를 통해 많은 행위엔터티를 생성한다. 예를 들어 계약, 사고, 예금원장, 청구, 주문, 매출.

**행위엔터티**는 두 개 이상의 부모엔터티로부터 발생되고 자주 내용이 바뀌거나 데이터량이 증가된다. 분석초기 단계에서는 잘 나타나지 않으며 상세 설계단계나 프로세스와 상관모델링을 진행하면서 도출될 수 있다. 예를 들어 주문목록, 사원변경이력 등이 포함된다.

### 속성

### 속성의 정의

- 업무에서 필요로 한다.
- 의미상 더 이상 분리되지 않는다.
- 엔터티를 설명하고 인스턴스의 구성요소가 된다.

### 엔터티, 인스턴스, 속성의 관계

엔터티에는 두 개 이상의 인스턴스가 존재하고 각각의 엔터티에는 고유의 성격을 표현하는 속성정보를 두 개 이상 갖는다. 업무에서는 여러 인스턴스가 가지는 동일한 성격을 파악하고 이름을 부여하여 엔터티의 속성으로 기술하는 작업 필요. 예를 들면 사원은 이름, 주소, 전화번호, 직책 등을 가질 수 있다. 사원이라는 엔터티에 속한 인스턴스들의 성격을 구체적으로 나타내는 항목이 바로 속성이다. 각각의 인스턴스는 속성의 집합으로 설명될 수 있다. 하나의 속성은 하나의 인스턴스에만 존재할 수 있다. 속성은 관계로 기술될 수 없고 자신이 속성을 가질 수도 없다.
엔터티 내에 있는 하나의 인스턴스는 각각의 속성들의 대해 한 개의 속성값만을 가질 수 있다. 예를 들면 사원의 이름은 홍길동이고 주소는 서울시 강남구이며, 전화번호는 123-4567, 직책은 대리이다. 이름, 주소, 전화번호, 직책은 속성이고 홍길동, 서울시 강남구, 123-4567, 대리는 속성값이다. 그러므로 속성값은 각각의 엔터티가 가지는 속성들의 구체적인 내용이라 할 수 있다.

### 정리

- 한 개의 엔터티는 두 개 이상의 인스턴스의 집합이어야 한다.
- 한 개의 엔터티는 두 개 이상의 속성을 갖는다.
- 한 개의 속성은 한 개의 속성값을 갖는다.
- 속성의 엔터티의 구체적인 정보이며 각각의 속성은 구체적인 값을 가진다.

### 속성의 특징

- 엔터티와 마찬가지로 반드시 해당 업무에서 필요하고 관리하고자 하는 정보이어야 한다. (예, 강사의 교재이름)
- 정규화 이론에 근간하여 정해진 주식별자에 함수적 종속성을 가져야 한다.
- 하나의 속성에는 한 개의 값만을 가진다. 하나의 속성에 여러 개의 값이 있는 다중값일 경우 별도의 엔터티를 이용하여 분리한다.

### 속성의 분류

### 속성의 특성에 따라

- 기본 속성은 업무로부터 추출한 모든 속성이 여기에 해당하며 엔터티에 가장 일반적이고 많은 속성을 차지한다. 코드성 데이터, 엔터티를 식별하기 위해 부여된 일련번호, 그리고 다른 속성을 계산하거나 영향을 받아 생성된 속성을 제외한 모든 속성은 기본속성이다. 주의해야 할 것은 업무로부터 분석한 속성이라도 이미 업무상 코드로 정의한 속성이 많다는 것이다. 이러한 경우도 속성의 값이 원래 속성을 나타내지 못하므로 기본속성이 되지 않는다.
- 설계속성은 업무상 필요한 데이터 이외에 데이터 모델링을 위해, 업무를 규칙화하기 위해 속성을 새로 만들거나 변형하여 정의하는 속성이다. 대개 코드성 속성은 원래 속성을 업무상 필요에 의해 변형하여 만든 설계속성이고 일련번호와 같은 속성은 단일(Unique)한 식별자를 부여하기 위해 모델 상에서 새로 정의하는 설계속성이다.
- 파생속성은 다른 속성에 영향을 받아 발생하는 속성으로서 보통 계산된 값들이 이에 해당된다. 다른 속성에 영향을 받기 때문에 프로세스 설계 시 데이터 정합성을 유지하기 위해 유의해야 할 점이 많으며 가급적 파생속성을 적게 정의하는 것이 좋다.

예를 들어 ‘이자’라는 속성이 존재한다고 하면 이자는 원금이 1,000원이고 예치기간이 5개월이며 이자율이 5.0%에서 계산되는 속성값이다. 그렇다면 이자는 원금이 1,000원에서 2,000원으로 변하여도 영향을 받고 예치기간이 5개월에서 7개월로 증가하여도 값이 변하며 이자율이 5.0%에서 6.0%로 되어도 이자속성이 가지는 값은 변할 것이다. 한 번 값이 변해도 또 다시 영향을 미치는 속성값의 조건이 변한다면 이자의 값은 지속적으로 변경될 것이다.

이와 같이 타 속성에 의해 지속적으로 영향을 받아 자신의 값이 변하는 성질을 가지고 있는 속성이 파생속성이다. **파생속성은 될 수 있으면 꼭 필요한 경우에만 정의**하도록 하여 업무로직이 속성내부에 숨지 않도록 하는 것이 좋다. 파생속성을 정의한 경우는 속성정의서에 파생속성이 가지는 업무로직을 기술하여 데이터의 정합성이 유지될 수 있도록 해야 하며 그 파생속성에 원인이 되는 속성을 이용하는 모든 애플리케이션에서는 값을 생성하고, 수정하고 삭제할 때 파생속성도 함께 고려해 주어야 한다. 파생속성은 일반 엔터티에서는 많이 사용하지 않으며 통계관련 엔터티나 배치 작업이 수행되면서 발생되는 엔터티의 경우 많이 이용된다.

### 엔터티 구성방식에 따라

엔터티를 식별할 수 있는 속성을 PK(Primary Key)속성, 다른 엔터티와의 관계에서 포함된 속성을 FK(Foreign Key)속성, 엔터티에 포함되어 있고 PK, FK에 포함되지 않은 속성을 일반속성이라 한다.

속성은 그 안에 세부 의미를 쪼갤 수 있는지에 따라 단순형 혹은 복합형으로 분류할 수 있다. 예를 들면 주소 속성은 시, 구, 동, 번지 등과 같은 여러 세부 속성들로 구성될 수 있는데 이를 복합 속성(Composite Attribute)이라 한다. 또한 나이, 성별 등의 속성은 더 이상 다른 속성들로 구성될 수 없는 단순한 속성이므로 단순 속성(Simple Attribute)이라 한다.

일반적으로 속성은 하나의 값을 가지고 있으나, 그 안에 동일한 성질의 여러 개의 값이 나타나는 경우가 있다. 이 때 속성 하나에 한 개의 값을 가지는 경우를 단일값(Single Value), 그리고 여러 개의 값을 가지는 경우를 다중값(Multi Value) 속성이라 한다. 주민등록번호와 같은 속성은 반드시 하나의 값만 존재하므로 이 속성은 단일값 속성(Single-Valued Attribute)이라 하고, 어떤 사람의 전화번호와 같은 속성은 집, 휴대전화, 회사 전화번호와 같이 여러 개의 값을 가질 수 있다. 자동차의 색상 속성도 차 지붕, 차체, 외부의 색이 다를 수 있다. 이런 속성을 다중값 속성(Multi-Valued Attribute)이라 한다. 다중값 속성의 경우 하나의 엔터티에 포함될 수 없으므로 1차 정규화를 하거나, 아니면 별도의 엔터티를 만들어 관계로 연결해야 한다.

### 도메인

각 속성은 가질 수 있는 값의 범위. ex) 학점은 0.0~4.0. 각 속성은 도메인 이하의 값을 가질 수 없다.

### 관계

- 엔터티의 인스턴스 사이의 논리적인 연관성으로서 존재의 형태로서나 행위로서 서로에게 연관성이 부여된 상태.
- 엔터티와 엔터티 간 연관성을 표현

### 각각의 엔터티의 인스턴스들은 자신이 관련된 인스턴스들과 관계의 어커런스로 참여하는 형태를 관계 패어링(Relationship Paring)이라 한다.

- 개별 인스턴스가 각각 다른 종류의 관계를 가지고 있다면 두 엔터티 사이에 두 개 이상의 관계가 형성될 수 있다.

### 관계의 분류

왼쪽 사진의 황경빈 사원은 DB팀에 소속되어 있는 상태다. ‘소속된다’의 의미는 행위에 따른 이벤트에 의해 발생되는 의미가 아니고 그냥 황경빈 사원이 DB팀에 소속되어 있기 때문에 나타나는 즉 존재의 형태에 의해 관계가 형성되어 있는 것이다.

오른편에 있는 김경재 고객은 ‘주문한다’라는 행위를 하여 CTA201이라는 주문번호를 생성. 주문 엔터티의 CTA201 주문번호는 김경재 고객이 ‘주문한다’라는 행위에 의해 발생되었기 때문에 두 엔터티 사이의 관계는 행위에 의한 관계가 되는 것이다.

### 연관관계와 의존관계 ( 클래스다이어그램의 관계 )

- 연관관계는 항상 이용하는 관계로 존재적 관계에 해당하고 의존관계는 상대방 행위에 의해 관계가 형성될 때 표현
- ERD에서는 존재적 관계와 행위에 의한 관계를 구분하지 않고 표현, 클래스다이어그램에서는 연관관계는 실선으로 표현, 소스코드에서 멤버변수로 선언하여 사용. 의존관계는 점선으로 표현, 행위를 나타내는 코드인 Operation(Method)에서 파라미터 등으로 이용.

### 관계의 표기법

- 관계명(Membership) : 관계의 이름
- 관계차수(Cardinality) : 1:1, 1:M, M:N
- 관계선택사양(Optionality) : 필수관계, 선택관계

### 관계명

관계명은 엔터티가 관계에 참여하는 형태를 지칭. 각각의 관계는 두 개의 관계명을 가지고 있다. 또한 각각의 관계명에 의해 두 가지의 관점으로 표현될 수 있다.

엔터티에서 관계가 시작되는 편을 관계시작점, 받는 편을 관계끝점이라 부름. 시작점과 끝점 모두 관계이름을 가져야 하며 관점에 따라 이름이 능동적(Active)이거나 수동적(Passive)으로 명명된다.

- 관계 명명 규칙
  - 애매한 동사를 피한다. 예를 들면 ‘관계된다’, ‘관련이 있다’, ‘이다’, ‘한다’ 등은 구체적이지 않아 어떤 행위가 있는지 또는 두 참여자간 어떤 상태가 존재하는지 파악할 수 없다.
  - 현재형으로 표현한다. 예를 들면 ‘수강을 신청했다’, ‘강의를 할 것이다’라는 식으로 표현해서는 안된다. ‘수강 신청한다’, ‘강의를 한다’로 표현해야 한다.

### 관계차수

두 개의 엔터티간 관계에서 참여자의 수를 표현. 가장 일반적인 관계차수 표현방법은 1:M, 1:1, M:N. 한 개의 관계가 존재하느냐 아니면 두 개 이상의 멤버쉽이 존재하는지를 파악하는 것이 중요

### 관계선택사양

> 만약 지하철 문이 닫히지 않았는데 지하철이 떠난다면 무슨 일이 발생할까? 머리만 지하철 안에 들어오고 몸은 밖에 있는 채로 끌려갈 것이다. “반드시 지하철의 문이 닫혀야만 지하철은 출발한다.”라는 지하철출발과 지하철문닫힘은 필수적으로 연결 관계가 있는 것이다. 이와 같은 것이 데이터 모델의 관계에서는 필수참여관계가 된다.

> 또 지하철 안내방송시스템의 예를 들어보자. 지하철의 출발을 알리는 안내방송은 지하철의 출발과 상관없이 방송해도 아무런 문제가 발생하지 않는다. 가끔씩 시스템의 녹음된 여성의 목소리가 아닌 시끄러운 남자 기사가 방송을 하는 경우가 있다. 시스템이 고장이 나도 운행에 별로 영향을 주지 않는다. 방송시점도 조금씩 달라도 지하철이 출발하는 것과는 연관되지 않는다. 이와 같이 지하철의 출발과 방송과는 정보로서 관련은 있지만 서로가 필수적인 관계는 아닌 선택적인 관계가 되는 것이다. 이런 메이터 모델 관계가 선택참여관계이다.

이와 같은 것이 데이터 모델 관계에서는 선택참여관계(Optional)가 된다. 참여하는 엔터티가 항상 참여하는지 아니면 참여할 수도 있는지를 나타내는 방법이 필수와 선택참여.

필수참여는 참여하는 모든 참여자가 반드시 관계를 가지는, 타 엔터티의 참여자와 연결이 되어야 하는 관계. 주문서는 반드시 주문목록을 가져야 하며 주문목록이 없는 주문서는 의미가 없으므로 주문서와 주문목록은 필수참여관계.

반대로 목록은 주문이 될 수도 있고 주문이 되지 않은 목록이 있을 수도 있으므로 목록과 주문목록과의 관계는 선택참여(Optional Membership)가 되는 것이다. 선택참여된 항목은 Foreign Key로 연결될 경우 Null을 허용할 수 있는 항목이 된다. 선택참여로 지정해야 할 관계를 필수참여로 잘못 지정하면 애플리케이션에서 데이터가 발생할 때 반드시 한 개의 트랜잭션으로 제어해야 하는 제약사항이 발생한다. 그러므로 설계단계에서 필수참여와 선택참여는 업무 로직과 직접적으로 관련된 부분이므로 반드시 고려.

선택참여관계는 ERD에서 관계를 나타내는 선에서 선택참여하는 엔터티 쪽을 원으로 표시한다. 필수참여는 아무런 표시를 하지 않는다.

만약 관계가 표시된 양쪽 엔터티에 모두 선택참여가 표시된다면, 즉 0:0의 관계가 된다면 그 관계는 잘못될 확률이 많으므로 관계설정이 잘못되었는지를 검토해 보아야 한다.

### 관계의 정의

### 체크 사항

- 두 개의 엔터티 사이에 연관규칙이 존재하는가?
- 두 개의 엔터티 사이에 정보의 조합이 발생되는가?
- 업무기술서에 관계연결에 대한 규칙이 서술되어 있는가?
- 업무기술서에 관계연결을 가능하게 하는 동사(Verb)가 있는가?

### 관계 읽기

- 기준 엔터티를 “한 개” 또는 “각”으로 읽는다.
- 대상 엔터티의 관계참여도 즉 개수(하나, 하나 이상)를 읽는다.
- 관계선택사양과 관계명을 읽는다.

### 식별자

엔터티는 인스턴스들의 집합. 여러 개의 집합체를 담고 있는 통에서 구분할 수 있는 논리적인 이름이 필요. 이 구분자를 식별자라고 함. 식별자란 하나의 엔터티에 구성되어 있는 여러 개의 속성 중에 엔터티를 대표할 수 있는 속성을 의미, 하나의 엔터티는 반드시 하나의 유일한 식별자가 존재해야 한다. 보통 식별자와 키(Key)를 동일하게 생각하는 경우가 있는데 식별자는 논리 데이터 모델링 단계에서 사용하고 키는 데이터베이스 테이블에 접근을 위한 매개체로서 물리 데이터 모델링 단계에서 사용한다.

### 주식별자 특징

- 주식별자에 의해 엔터티내에 모든 인스턴스들이 유일하게 구분되어야 한다. 대표성을 가짐. (유일성)
- 주식별자를 구성하는 속성의 수는 유일성을 만족하는 최소의 수가 되어야 한다. 고유코드가 여러개 일 필요가 없다. (최소성)
- 지정된 주식별자의 값은 자주 변하지 않는 것이어야 한다. ex 사원번호 (불변성)
- 주식별자가 지정이 되면 반드시 값이 들어와야 한다. Null 안된다. (존재성)

### 식별자 분류

- 자신의 엔터티 내에서 대표성을 가지는가에 따라 주식별자와 보조식별자로 구분
- 스스로 생성되었는지 여부에 따라 내부식별자와 외부식별자로 구분
- 단일 속성으로 식별이 되는가에 따라 단일식별자와 복합식별자로 구분

### 주식별자 도출기준

- 해당 업무에서 자주 이용되는 속성을 주식별자.
  - 예를 들면, 직원이라는 엔터티가 있을 때 유일하게 식별가능한 속성으로는 주민등록번호와 사원번호가 존재할 수 있다. 사원번호가 그 회사에서 직원을 관리할 때 흔히 사용되므로 사원번호를 주식별자로 지정, 주민등록번호는 보조식별자로 사용할 수 있다.
- 명칭, 내역 등과 같이 이름으로 기술되는 것들은 가능하면 주식별자로 지정하지 않는다.

  - 부서이름을 주식별자로 지정하지 않도록 해야 한다. 부서이름을 주식별자로 선정하면 물리데이터베이스로 테이블을 생성하여 데이터를 읽을 때 항상 부서이름이 WHERE 조건절에 기술되는 현상이 발생된다. 부서이름은 많은 경우 20자 이상이 될 수 있으므로 조건절에 정확한 부서이름을 기술하기는 쉬운 일이 아니다.
  - 이와 같이 명칭이나 내역이 있고 인스턴스들을 식별할 수 있는 다른 구분자가 존재하지 않을 경우는 새로운 식별자를 생성하도록 한다. 보통 일련번호와 코드를 많이 사용한다.

  - 부서명과 같은 경우는 부서코드를 부여하여 코드엔터티에 등록한 후 부서코드로 주식별자를 지정하는 방법과 부서일련번호(부서번호)를 주식별자로 하고 부서명은 보조식별자로 활용하는 두 가지 방법이 있다.

- 복합으로 주식별자로 구성할 경우 너무 많은 속성이 포함되지 않도록 한다.

  - 주식별자로 선정하기 위한 속성이 복합으로 구성되어 주식별자가 될 수 있을 때 가능하면 주식별자 선정하기 위한 속성의 수가 많지 않도록 해야 한다

- 왼편 그림에서 접수 엔터티에 어떤 부류의 사람이 특정접수방법에 의해 특정 날짜에 여러 번 신청하는 것을 접수담당자가 입력한 대로 데이터가 식별될 수 있는 업무 규칙이 있는 경우이다. 접수의 주식별자가 접수일자, 관할부서, 입력자사번, 접수방법코드, 신청인구분코드, 신청자주민번호, 신청회수 등 7개 이상의 복잡한 속성을 가지고 있다. 이러한 모델의 경우 실제 테이블에 Primary Key는 7개가 생성될 것이고 만약 특정 신청인의 계약금 하나만 가져온다고 하더라도 다음과 같이 복잡한 SQL문장을 구사해야 한다.

이렇게 된 SQL문장을 접수번호라고 하는 인조식별자로 대체했다고 하면 특정신청인의 계약금 조회는 다음과 같이 간단하게 할 수 있다.

SELECT 계약금 FROM 접수 WHERE 접수.접수일자 = ‘100120100715001“

### \***\*식별자관계와 비식별자관계에 따른 식별자\*\***

### 외부식별자

- 자기 자신의 엔터티에서 필요한 속성이 아니라 다른 엔터티와의 관계를 통해 자식 쪽에 엔터티에 생성되는 속성
- 데이터베이스 생성 시에 Foreign Key역할
- 엔터티에 주식별자가 지정되고 엔터티간 관계를 연결하면 부모쪽의 주식별자를 자식엔터티의 속성으로 내려 보낸다. 이 때 자식엔터티에서 부모엔터티로부터 받은 외부식별자를 자신의 주식별자로 이용할 것인지 또는 부모와 연결이 되는 속성으로서만 이용할 것인지를 결정해야 한다.

### 식별자 관계

- 부모로부터 받은 식별자를 자식엔터티의 주식별자로 이용하는 경우는 Null값이 오면 안되므로 반드시 부모엔터티가 생성되어야 자기 자신의 엔터티가 생성되는 경우
- 부모로부터 받은 속성을 자식엔터티가 모두 사용하고 그것만으로 주식별자로 사용한다면 부모엔터티와 자식엔터티의 관계는 1:1의 관계가 될 것이고 만약 부모로부터 받은 속성을 포함하여 다른 부모엔터티에서 받은 속성을 포함하거나 스스로 가지고 있는 속성과 함께 주식별자로 구성되는 경우는 1:M 관계가 된다.

발령엔터티는 반드시 사원엔터티가 있어야 자신도 생성될 수 있고 자신의 주식별자도 부모엔터티의 외부식별자 사원번호와 자신의 속성 발령번호로 이루어져 있음을 알 수 있다. 이 때 사원과 발령의 관계는 1:M 관계이다. 또한 사원과 임시직사원의 관계와 주식별자를 보면, 임시직사원의 주식별자는 사원의 주식별자와 동일하게 이용되는 경우를 볼 수 있다. 1:1 관계에서 이와 같이 나타나며 주식별자가 동일하며 엔터티 통합의 대상이 됨을 알 수 있다. 자식엔터티의 주식별자로 부모의 주식별자가 상속이 되는 경우를 식별자 관계라고 지칭한다.

### 비식별자 관계

- 부모엔터티로부터 속성을 받았지만 자식엔터티의 주식별자로 사용하지 않고 일반적인 속성으로만 사용하는 경우
- 자식엔터티에서 받은 속성이 반드시 필수가 아니어도 무방하기 때문에 부모 없는 자식이 생성될 수 있는 경우
- 부모엔터티에 인스턴스가 자식의 엔터티와 관계를 가지고 있었지만 자식만 남겨두고 먼저 소멸될 수 있는 경우

- 접수엔터티가 인터넷접수, 내방접수, 전화접수가 하나로 통합되어 표현되어 있는 경우에 해당되며 통합된 엔터티에 각각의 엔터티가 별도의 관계를 가지고 있고 각각의 관계로부터 받은 주식별자를 접수엔터티의 주식별자로 사용할 수 없는 모습을 보여준다.

- 계약이 반드시 사원에 의해 이루어져 사원번호와 계약번호로 주식별자를 구성할 수 있지만 계약번호 단독으로도 계약 엔터티의 주식별자를 구성할 수 있으므로 하나만 가지고 있는 것이 더 효율적이라고 판단하여 계약번호만 주식별자로 하고 계약사원번호는 일반속성 외부식별자로서 사용하게 된 경우이다.

PLANT의 경우 단지 한 개의 속성만이 PK속성이었으나 EQPEVTSTSHST 엔터티의 경우 부모로부터 모두 식별자관계 연결로 인해 PK속성의 개수 5개 설정.

즉, PLANT 엔터티에는 PK속성의 수가 1개이고 관계가 1:M으로 전개되었으므로 자식엔터티는 PLANT 엔터티의 PK속성의 수 + 1이 성립된다. 물론 1개 이상의 속성의 추가되어야 1:M 관계를 만족할 수 있다. 이와 같은 원리에 의해 1:M 관계의 식별자관계의 PK속성의 수는 다음과 같다.

원 부모엔터티 : 1개 2대 부모엔터티 : 2개 이상 = 원부모 1개 + 추가 1개 이상 + 3대 부모엔터티 : 3개 이상 = 원부모 1개 + 2대 1개 + 추가 1개 이상 3대 부모엔터티 : 3개 이상 = 원부모 1개 + 2대 1개 + 3대 1개 + 추가 1개 이상 4대 부모엔터티 : 4개 이상 = 원부모 1개 + 2대 1개 + 3대 1개 + 4 1개 + 추가 1개 이상 ....

이와 같은 규칙에 의해 지속적으로 식별자 관계를 연결한 데이터 모델의 PK속성의 수는 데이터 모델의 흐름이 길어질수록 증가할 수 밖에 없는 구조를 가지게 된다.

> 별자 관계만으로 연결된 데이터 모델의 특징은 주식별자 속성이 지속적으로 증가할 수 밖에 없는 구조로서 개발자 복잡성과 오류가능성을 유발시킬 수 있는 요인이 될 수 있다는 사실을 기억

### 비식별자 관계로만 설정할 경우의 문제점

- 일반적으로 각각의 엔터티에는 중요한 기준 속성이 있는데 이러한 기준속성은 부모엔터티에 있는 PK속성으로부터 상속되어 자식엔터티에 존재하는 경우가 많다. 이러한 속성의 예로 ‘주민등록번호’, ‘사원번호’, ‘주문번호’, ‘목록번호’ 등이 있다. 이런 속성은 부모엔터티를 조회할 때도 당연히 쓰이지만 자식엔터티의 데이터를 조회할 때도 해당 조건이 조회의 조건으로 걸리는 경우가 다수이다. 그런데 데이터 모델링을 전개할 때 각 엔터티간 관계를 비식별자 관계로 설정하면 이런 유형의 속성이 자식엔터티로 상속이 되지 않아 자식엔터티에서 데이터를 처리할 때 쓸데없이 부모엔터티까지 찾아가야 하는 경우가 발생

> 식별, 비식별자 관계에 대해 일정한 규칙을 가지고 데이터 모델링을 하는 기술이 필요

### \***\*식별자관계와 비식별자관계 모델링\*\***

### 비식별자관계 선택 프로세스

실제로 프로젝트를 전개할 때 식별, 비식별자관계를 취사선택하여 연결하는 내공은 높은 기술을 요함. 특히 식별에서 비식별자관계를 파악하는 기술이 필요한데 다음 흐름(Flow)에 따라 비식별자관계를 선정한다면 합리적으로 관계를 설정하는 모습이 될 수 있다. 기본적으로 식별자관계로 모든 관계가 연결되면서 다음 조건에 해당할 경우 비식별자관계로 조정하면 된다.

- 자식엔터티의 독립된 주식별자 구성이 필요한지를 분석하는 부분. 독립적으로 주식별자를 구성한다는 의미는 업무적 필요성과 성능상 필요여부를 모두 포함하는 의미로 이해.

### 식별자와 비식별관계 비교 (강한 관계인 식별자관계와 약한 관계인 비식별자관계를 비교)

### 균형잡힌 데이터 모델

### 모델링

- 표기법에 의해 규칙을 가지고 표기하며 모델을 만들어가는 일
- • 정보시스템을 구축하기 위해, 해당 업무에 어떤 데이터가 존재하는지 또는 업무가 필요로 하는 정보는 무엇인지를 분석하는 방법

= 데이터를 시스템 분석하고 설계하여 정보시스템을 구축하는 과정

### 데이터 모델링을 하는 이유

- 정보시스템 구축의 대상이 되는 업무 내용을 정확하게 분석
- 분석된 모델을 가지고 실제 데이터베이스를 생성하여 개발 및 데이터관리에 사용하기 위한 것

### 데이터 모델이 제공하는 기능

- 시스템을 현재 or 원하는 모습으로 가시화하도록 도움
- 시스템의 구조와 행동을 명세화
- 시스템을 구축하는 구조화된 틀 제공
- 시스템을 구축하는 과정 중 결정한 것을 문서화
- 다양한 영역에 집중하기 위해 다른 영역의 세부 사항은 숨기는 다양한 관점 제공
- 특정 목표에 따라 구체화된 상세 수준의 표현방법 제공

### 모델링 특징

1. 추상화 : 현실세계를 일정한 형식에 맞추어 표현
2. 단순화 : 현실세계를 약속에 의해 제한된 표기법이나 언어로 표현하여 쉽게 이해할 수 있도록 함
3. 명확화 : 이해하기 쉽게 하기 위해 대상에 대한 애매모호함을 제거하고 정확하게 현상을 기술

### 모델링은 크게 세 가지 관점

1. **데이터관점** : 업무가 어떤 데이터와 관련이 있는지 또는 데이터간의 관계는 무엇인지에 대해서 모델링하는 방법(What, Data)

2. **프로세스관점** : 업무가 하고 있는 일은 무엇인지 또는 무엇을 해야 하는지를 모델링하는 방법(How, Process)

3. **데이터와 프로세스의 상관관점** : 업무가 처리하는 일의 방법에 따라 데이터는 어떻게 영향을 받고 있는지 모델링하는 방법

### 데이터 모델링의 중요성 및 유의성

### 파급효과

데이터는 많은 단위 테스트를 함. 단위 테스트들이 성공적이면 묶어서 병행테스트, 통합테스트를 수행. 이 때, 데이터 모델의 변경이 불가피한 상황이 발생하면 데이터 구조의 변경에 따른 표준 영향 분석 등 많은 영향 분석이 일어나고 그 후 실제적인 변경 작업이 발생한다. 데이터 모델의 형태에 따라서 차이가 있겠지만 데이터 구조의 변경으로 인한 일련의 변경작업은 전체 프로젝트에서 큰 위험요소가 아닐 수 없다. 이러한 이유로 시스템 구축 작업 중에서 다른 어떤 설계 과정보다 데이터 설계가 더 중요하다고 볼 수 있다.

> 데이터의 작은 설계의 균열도 영향이 크기 때문에 초기의 모델 설계가 중요하다.

### 복잡한 요구사항의 간결한 표현

데이터 모델은 건축물로 비유하자면 설계 도면.

데이터 모델은 구축할 시스템의 정보 요구사항과 한계를 가장 명확하고 간결하게 표현할 수 있는 도구. 정보 요구사항은 간결하게 그려져 있는 데이터 모델을 리뷰하면서 파악하는 것이 빠른 방법.

> 정보 요구사항이 정확하고 간결하게 표현되어야 한다

### 데이터 품질

데이터베이스에 담겨 있는 데이터는 기업의 중요한 자산. 중복 데이터의 미정의, 데이터 구조의 비즈니스 정의의 불충분, 동일한 성격의 데이터를 통합하지 않고 분리함 등은 데이터 불일치를 일으키고 데이터 품질의 저하를 낳는다. 그리하여 데이터 모델링을 할 때는 다음을 유의해야한다.

1. **중복** : 데이터 모델은 같은 데이터를 사용하는 사람, 시간, 장소를 파악하는데 도움을 줌. 이러한 지식 응용은 데이터베이스가 여러 장소에 같은 정보를 저장하는 잘못을 하지 않도록 함
2. **비유연성** : 데이터 모델을 어떻게 설계했느냐에 따라 사소한 업무변화에도 데이터 모델이 수시로 변경됨으로 유지보수의 어려움을 가중시킬 수 있다. 데이터의 정의를 프로세스와 분리함으로써 데이터, 프로세스의 작은 변화가 애플리케이션과 데이터베이스에 중대한 변화를 일으킬 수 있는 가능성을 줄임
3. **비일관성** : 데이터의 중복이 없더라도 비일관성은 발생한다. 예를 들어 신용 상태에 대한 갱신 없이 고객의 납부 이력 정보를 갱신하는 것이다. 개발자가 다른 데이터와 모순된다는 고려 없이 일련의 데이터를 수정할 수 있기 때문이다. 데이터 모델링을 할 때 데이터간 상호 연관 관계에 대한 명확한 정의는 위험을 사전에 예방할 수 있도록 해준다.

### 데이터 모델링의 진행

### 개념적 데이터 모델링

데이터와 자료의 우선순위를 정하는 과정. 중요한 것은 엔터티-관계 다이어그램을 생성 ( 핵심 엔터티와 그들 간의 관계를 발견, 표현 ) 데이터 모델링 과정이 전 조직에 걸쳐 이루어진다면, 그것은 **전사적 데이터 모델**이라 불림.

개념 데이터 모델을 통해 조직의 데이터 요구를 공식화하는 것은 두 가지의 중요한 기능을 지원

- 사용자와 개발자가 시스템 기능에 대해서 논의할 수 있는 기반을 형성
- 현 시스템이 어떻게 변형되어야 하는가를 이해하는데 유용하다. 일반적으로 매우 간단하게 고립된(Stand Alone) 시스템도 추상적 모델링을 통해서 보다 쉽게 표현되고 설명

### 논리적 데이터 모델링

데이터베이스 설계 프로세스의 Input. 비즈니스 정보의 논리적인 구조와 규칙을 명확하게 표현하는 과정. 논리 데이터 모델은 스키마 설계를 하기 전에 비즈니스 데이터에 존재하는 사실들을 인식하여 기록하는 것. 논리 데이터를 모델링 할 때 **정규화**라는 활동이 필요. **정규화**는 논리 데이터 모델 상세화 과정의 대표적인 활동으로, 논리 데이터 모델의 일관성을 확보하고 중복을 제거하여 속성들이 가장 적절한 엔터티에 배치되도록 함으로써 보다 신뢰성있는 데이터구조를 얻는데 목적.

- 논리 데이터 모델의 예 : 논리 데이터 모델의 상세화는 식별자 확정, 정규화, M:M 관계 해소, 참조 무결성 규칙 정의

### 물리적 데이터 모델링

- 데이터가 물리적으로 컴퓨터에 어떻게 저장될 것인가에 대한 정의
- 테이블, 칼럼 등으로 표현되는 물리적인 저장구조와 사용될 저장 장치, 자료를 추출하기 위해 사용될 접근 방법 등이 결정
