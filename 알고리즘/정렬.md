<aside>
💡 Git의 작동 원리에 대하여 다루고있습니다.

</aside>

# 시간복잡도

---

정렬은 시간복잡도가 중요하다. 문제에 따라 어느 정렬을 사용할지를 선택해야한다.

기본적인 sort() = O(nlogn)

HashTable O(n) // HashTable 검색 : O(1)

문제에서 일반적인 완전탐색 O(n^2)를 사용하는경우 입력값이 (10^4)만 넘어도 1억이 나온다. 이런경우 완전탐색의 방법으로 풀면 안되고 O(nlogn)이나 O(n), O(logn)의 알고리즘을 생각해야한다.

기본적인 sort()는 O(nlogn)이 걸리기 때문에 빠르게 사용할 수 있다.

# 정렬

---

정렬이란 데이터를 특정한 기준에 따라 순서대로 나열하는것을 말한다.

보통 정렬 알고리즘은 문제 상황에 따라 적절한 정렬 알고리즘이 공식처럼 사용된다.

- 데이터의 개수가 적을때
- 데이터의 개수가 많지만 범위가 특정 할 때
- 이미 거의 정렬되어 있을 때

여러가지 상황에 따라 적절한 알고리즘을 사용을 해야한다.

### 선택 정렬 O(N^2)

처리되지 않은 데이터 중에서 가장 작은 데이터를 선택해 맨 앞에 데이터와 바꾸는 것을 반복한다.

min_index를 사용하여 최솟값을 찾고 앞에서부터 하나씩 swap을 한다.

### 삽입 정렬 O(N^2) 최선의 경우 O(N)

처리되지 않은 데이터를 하나씩 골라 적절한 위치에 삽입한다.

선택 정렬에 비해 구현 난이도가 높은 편이지만, 일반적으로 더 효율적으로 동작한다. 0번째 인덱스를 정렬되었다고 생각하여 다음 인덱스를 이전 인덱스랑 비교하여 swap을 반복하여 정렬을 완성시킨다. **삽입 정렬은 거의 정렬되어 있는 상태라면 매우 빠르게 작동한다.**

```java
public static void main(String[] args){
	for(i = 1 ; i < num.length() ; i++){
		for(j = i ; j > 0 ; j--){
			if(arr[j]<arr[j-1]){
				 swap(); //swap함수 구현
			}
			else break;
		}
	}
}
```

### 퀵 정렬 평균 : O(nlogn) 최악 : O(N^2)

기준 데이터를 설정하고 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸는 방법이다.

일반적으로 데이터의 특성과 관련 없이 표준적으로 사용 할 수 있는 정렬 알고리즘 중 하나이다.

병합 정렬과 더불어 대부분 프로그래밍 언어의 정렬 라이브러리의 근간이 되는 알고리즘이다.

가장 기본적인 퀵 정렬은 첫 번째 데이터를 기준 데이터(Pivot)로 설정한다.

Pivot을 설정했으면 왼쪽에선 Pivot보다 큰 값을, 오른쪽에선 Pivot보다 작은 값을 정해서 데이터를 바꾸고 엇갈릴경우 Pivot과 작은 데이터의 위치를 바꾼다. 그럼 Pivot은 중간으로 들어가고 Pivot 기준 왼쪽은 작은 값, 오른쪽은 큰 값이 된다. 그 후엔 작은 값과 큰 값을 배열로 만들어 다시 퀵 정렬을

재귀적으로 실행한다. 퀵 정렬 한 번 시 데이터가 반으로 줄어드니까 시간 복잡도는 logN. 데이터의 개수가 N 이므로 O(nlogn)이 된다. 하지만 표준 라이브러리를 이용하는 경우엔 항상 O(nlogn)을 보장한다.

```java
public class Main {
	public static void main(String[] args){
		int n = 10;
		int[] arr = {7,5,9,0,3,1,6,2,4,8};
		quickSort(arr,0,n-1);
	}

	public static void quickSort(int[] arr,int start,int end) {
		if(start>=end) return; //원소가 1개인 경우 종료
		int pivot = start;
		int left = start + 1;
		int right = end;
		while(left <= right) { //엇갈리지 않는한 반복

			// 피벗보다  큰 데이터 찾기
			while(left <= end && arr[left] <= arr[pivot]) left++;
			// 피벗보다 작은 데이터 찾기
			while(right > start && arr[right] >= arr[pivot]) right--;

			// 엇갈렸다면 작은데이터와 피봇을 바꾸기
			if(left > right) {
				int temp = arr[pivot];
				arr[pivot] = arr[right];
				arr[right] = temp;
			}
			else {
				int temp = arr[left];
				arr[left] = arr[right];
				arr[right] = temp;
			}
		}
		//분할 이후 왼쪽 부분과 오른쪽 부분에서 각각 정렬 수행
		quickSort(arr,start,right-1);
		quickSort(arr,right+1,end);
	}
}
```

### 계수 정렬 (Counting Sort) 시간 + 공간복잡도 = O(N+K)

특정한 조건이 부합할 때 사용할 수 있지만 매우 빠르게 동작하는 정렬 알고리즘이다.

데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때 사용한다.

데이터의 개수가 N, 최대값이 K일 때 최악의 경우에도 O(N+K)를 보장한다.

- 가장 작은 데이터부터 가장 큰 데이터까지 담길 수 있는 리스트를 만든다.
- 데이터를 하나씩 확인하며 데이터의 값과 동일한 인덱스의 데이터를 1씩 증가시킨다.
- 각 원소의 count 숫자대로 출력한다.

계수 정렬은 각각의 데이터가 몇 번 씩 나왔는지 세는 정렬 알고리즘이다. 모든 범위를 포함하는 크기의 배열을 만들어야 하기 때문에 공간복잡도가 높지만 퀵 정렬과 비교했을 때 조건 만족시 더 빠르게 동작한다. 하지만 데이터가 0과 999,999로 단 2개만 존재하는경우 총 100만개만큼의 배열을 만들어야한다. 계수배열은 동일한 값을 가지는 데이터가 여러 개 등장하는 경우 효과적으로 사용 할 수 있다

ex) 성적 등.
