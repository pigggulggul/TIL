# 👀 다이나믹 프로그래밍 (기억하며 풀기)

모든 알고리즘은 기존에 있던 문제를 해결하기 위해 고안되었다. 알고리즘이 왜 필요한지 이해한다면 어떤 문제에 적용할지 어떻게 적용할지 빠르게 익힐 수 있다. DP는 완전 탐색, DFS, BFS와 같이 수많은 경우의 수를 따져야하는데 너무 많아 수행시간을 단축하기 위해 만들어졌다.

예 : DP 삼각형

다이나믹 프로그래밍의 목적 : 메모리를 사용해서 중복연산을 줄이고 그로인해 수행 시간을 줄이는 거다. 메모리를 사용하는건 또 하나의 배열이나 자료구조를 만드는거고 연산한 결과를 배열에 담아 다시 계산하지 않는다는 것이다.

### DP의 사용 조건

DP가 적용되기 위해서는 2가지 조건을 만족해야 한다.

1. 겹치는 부분의 문제
2. 최적 부분 구조

1) DP는 기본적으로 문제를 나누고 그 문제의 결과 값을 재활용해서 전체 답을 구한다. **동일한 작은 문제들이 반복하여 나타나는 경우에 사용이 가능**하다. DP는 부분 문제의 결과를 저장하고 재 계산하지 않을 수 있어야 하는데, 해당 **부분 문제가 반복적으로 나타나지 않는다면 재사용이 불가능**하니 부분 문제가 중복되지 않는 경우에는 사용할 수 없다. (ex : 파보나치 수열)

2) **부분 문제의 최적 결과 값을 사용해 전체 문제의 최적 결과를 낼 수 있어야한다**. 이전의 결과값을 저장하여 사용하거나 최적 결과가 전체 문제에서도 동일하게 적용되어 결과가 변하지 않을 때 DP를 사용할 수 있게 한다.

DP는 특정한 경우에 사용하는 알고리즘이 아니라 하나의 방법론이라 다양한 문제해결에서 쓰일 수 있다.

### DP의 문제 풀이 과정

1. DP로 풀 수 있는 문제인지 확인.
2. 문제의 변수 파악
3. 변수 간 관계식 만들기
4. 메모하기
5. 기저 상태 파악
6. 구현하기

1) 보통 특정 데이터 내 최대화 / 최소화 계산을 하거나 특정 조건 내 데이터를 세야 한다거나 확률 등의 계산의 경우 DP로 풀 수 있는 경우가 많다.

2) 현재 변수에 따라 그 결과 값을 찾고 전달하여 재사용하는 것을 거친다. **피보나치 수열**에서는 n번째 숫자를 구하는 것이므로 n이 변수가 된다. 그 변수가 얼마이냐에 따라 결과값이 다르지만 그 결과를 재사용하고 있다.

3) 변수들에 의해 결과 값이 달라지지만 동일한 변수값인 경우 결과는 동일하다. 또한 우리는 그 결과값을 그대로 이용할 것이므로 그 관계식을 만들어낼 수 있어야 한다. 이런 식을 **점화식**이라고 부르며 그를 통해 짧은 코드 내에서 반복/재귀를 통해 문제가 자동으로 해결되도록 구축할 수 있게 된다.

4) 계식까지 정상적으로 생성되었다면 **변수의 값에 따른 결과를 저장한다.**

5) 가장 작은 문제의 상태를 알아야 한다. 이 때 몇 가지 예시를 손으로 테스트하며 구성하는 경우가 많다.

6) 구현은 Bottom-UP (반복문 사용)이나 Top-Down (재귀 사용)을 이용한다.

Divide and Conquer(분할 정복)과의 차이점.

분할 정복과 동적 프로그래밍은 문제를 쪼개서 하위 문제를 해결하고 연계적으로 큰 해결한다는 점이 같다. 하지만 분할 정복은 하위 문제가 동일하게 중복되어 일어나지 않는 경우에 사용한다.

---
