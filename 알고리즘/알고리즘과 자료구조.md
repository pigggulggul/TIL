대부분의 프로그램은 자료를 처리하고있고 이 자료들은 자료 구조를 사용하여 표현되고 저장한다. 그리고 이 문제를 처리하는 절차가 필요한데 이것을 알고리즘이라고 한다. 어떤 문제가 주어졌을 때 첫 번째 해야 할 일은 문제 해결 방법을 고민하는 것이다. 어떤 해결 방법이 ‘효율성있고 자원이 적게드는지’ 생각하고 찾아야한다. 두 번째로 할 일은 절차를 기술하는 것이다. 컴퓨터로 문제를 풀기 위한 단계적 절차를 알고리즘이라고 한다.

### 알고리즘을 기술하는 방법

- 자연어
- 흐름도
- 유사 코드
- 프로그래밍 언어

보통 4가지 방법으로 진행되는데 자연어는 모호한 부분이 많고 흐름도는 복잡해질수록 쓰기 어려워진다. 그래서 유사 코드나 프로그래밍 언어를 사용하여 알고리즘을 기술한다. 프로그래밍 언어는 모두 명백한 의미롤 가지고 있어서 알고리즘을 기술하는 데 안성맞춤이고 유사 코드는 자연어보다는 더 체계적이고 프로그래밍 언어보다는 덜 엄격하다.

### 추상적 데이터 타입.

추상적 데이터 타입이란 자료 구조를 추상적, 수학적으로 정의한 것이다. 데이터 타입을 추상적으로 정의하는것을 말하며 자세하게 말하면 데이터의 집합과 데이터에 가해지는 연산들의 수학적인 명세이다. “추상”인 이유가 데이터나 연산에 대해 추상적으로 정의되기 때문이다.

add(x,y), equal(x,y) 등을 우리가 사용하는데 컴퓨터는 이것의 자세한 코드를 알려주지 않고 무엇이고 어떤 의미인지만 설명해준다. 자세한 세부 사항은 외부에 알리지 않고 인터페이스만 사용하지만 우리는 이것을 몰라도 함수를 사용 할 수 있다. 이런 인터페이스를 ADT. 추상적 데이터 타입이라고 한다.

### 알고리즘의 중요한 요소 2가지 ( 시간 복잡도와 공간 복잡도 )

시간 복잡도를 계산 할 때 **빅오 표기법**으로 계산을 하는데 자료의 개수가 많은 경우 차수가 가장 큰 항이 영향을 크게 미치고 수행시간을 주도하기 때문에 다른 항들은 상대적으로 무시되고 최고차 항만을 고려한다. 시간 복잡도 함수에서 중요한 것은 n이 증가하였을 때 연산횟수가 n에 비례하는지 n^2에 비례하는지 등이 중요하다. 그리하여 불필요한 정보를 제거하여 알고리즘 분석을 쉽게 할 목적으로 시간 복잡도를 표시하는게 **빅오 표기법**이라고 한다.

### 최선과 평균, 최악

알고리즘의 실행 시간을 말할 때의 기준이며 보통 **최악의 경우**, **최선의 경우**, **평균적인 경우**로 나뉘어서 평가한다. 평균적인 실행 시간이 가장 좋지만 광범위한 자료들에 적용시켜서 구하기 힘들 수 있다. 그래서 **최악의 경우**의 실행 시간이 알고리즘의 시간 복잡도 척도로 많이 쓰인다. 최악의 경우는 중요한 의미를 가지는데 비행기 관제 업무 등 중요한 경우에는 일정한 시간 안에 반드시 계산을 끝마쳐야 한다. 이런 경우 최선의 경우는 의미가 없다.

### 자료 구조 표기법

- 상수 : 전체를 대문자로 ( MAX_ELEMENT, MAX_STACK_SIZE )
- 변수의 이름 : 소문자 + 웬만하면 약어금지 + 공백은 언더라인 (int increment, int new_node)
- 함수의 이름 : 동사를 이용하거나 널리 사용되는 이름 ( int add( ), int list_add( )

## 순환 (recursion)

순환은 어떤 알고리즘이나 함수가 자기 자신을 호출하여 문제를 해결하는 기법이다. 순환은 본질적으로 순환적으로 정의된 문제나 자료 구조를 다루는 프로그램에 적합하다. 순환 알고리즘은 **자기 자신을 호출하는 부분**과 **호출을 멈추는 부분**으로 구성되어있다. 호출을 멈추는 부분이 없으면 함수가 무한히 작동이 되어 멈추는 레버를 만들어야 한다. 순환의 경우 for나 while로도 구현 할 수 있다. 하지만 반복을 사용 시 지나치게 복잡해지는 문제들도 존재한다. 이런 경우 순환이 매우 좋은 해결책이 된다. 순환은 어떤 문제에서는 **반복에 비해 알고리즘을 훨씬 명확하고 간결하게 나타낼 수 있지만** 일반적으로 반복에 비해 **수행속도 면에서는 떨어진다**.

### 순환의 원리

집을 건축 할 때도 한 사람이 모든 공사를 하지 않고 여러 하청을 고용하여 집의 여러 부분을 완성시킨다. 하청은 다시 하청을 고용하여 맡은 일을 끝마치는데 이런 식으로 **주어진 문제를 작은 동일한 문제들로 분해하여 해결하는 방법을 분할 정복 (divide and conquer)이라고 한다**. 분할하기 때문에 점점 크기가 작아지며 풀기가 쉬워진다. 순환은 문제의 정의가 순환적으로 되어 있는 경우에 유리한 방법이다. 팩토리얼, 피보나치, 이항 계수, 이진 트리, 이진 탐색, 하노이탑 문제들은 순환 알고리즘을 쓰는 것이 자연스럽다.

### 순환 알고리즘의 성능

기본적으로 반복 알고리즘으로 구현했을 때의 시간 복잡도와 같다. 팩토리얼의 경우 O(n)이 된다. 결론적으로 순환 알고리즘은 이해하기 쉽다는 것과 쉽게 프로그램 할 수 있다는 장점이 있는 대신 수행 시간과 기억 공간의 사용에 있어서는 비효율적인 경우가 많다. 하지만 모든 알고리즘에서 반복이 빠르진 않는다. 거듭제곱을 구하는 경우에 2^500을 반복으로 구하는 경우 7.11초 순환으로 구하는 경우 0.47초가 걸린다. 이 때 시간 복잡도는 반복의 경우 O(n), 순환의 경우 O(log2n)이다.

### 리스트 - 선형리스트

리스트에는 보통 항목들이 차례대로 정리되어 있다. 리스트는 집합하고 다른게 **집합은 항목 간 순서의 개념이 없으나 리스트에는 항목들 간에 순서가 있다.** 리스트는 데이터를 위치에 추가, 제거, 클리어, 대치, 특정위치 반환 등이 있다. 배열로 된 리스트의 경우 데이터를 추가하고 삭제 할 때 데이터 시프트가 일어난다. 삽입의 경우 해당 위치까지 공간을 이동시키기에 시프트가 일어나고 삭제의 경우 데이터를 삭제를 한 후 맨 끝까지에 데이터를 당겨야하기 때문에 시프트가 일어난다.

- 자바에서의 리스트 - [Array 와 List](https://www.notion.so/Array-List-77c1f9ab709546a4b41ef5ce33e90380)

배열을 이용한 리스트 구현

배열을 이용하여 리스트를 구현 할 때 사용하는 것들

- 배열과 배열의 크기 변수.
- 배열이 비어있는치 차있는지 검사하는 isEmpty
- 내용을 출력하는 display
- 배열을 넣는 add() 함수.

add() 함수는 먼저 배열이 가득차지 않았나를 검사하기 때문에 비어있는지 차있는지를 먼저 확인해야한다.

### 리스트 - 연결리스트

선형 리스트는 구현이 간단하지만 크기가 고정되어 있다. 이러한 단점을 보완하기 위해 연결리스트란게 있다. 연결리스트는 동적으로 크기가 변할 수 있고 삭제나 삽입 시에 데이터 이동이 필요가 없다. 연결 리스트는 스택, 큐, 트리, 그래프 등 여러 곳에서 쓰인다. 하지만 오늘날 연결리스트는 잘 사용되지 않는데 연결리스트가 삽입과 삭제에 강한 모습을 드러내지만 데이터를 조회할 때 메모리 조회를 O(n)번을 해야하고 그만큼 메모리에 많이 접근한다. 이것은 성능저하와 연결될 수 있다. 연결리스트는 기차처럼 공간 - 선 - 공간 - 선 -공간의 구조이고 각 공간마다 임의의 메모리가 할당된다. 이러한 구조는 삽입과 삭제의 장점으로 연결되는데 데이터 시프트가 필요 없이 삽입과 삭제 시에 공간을 이어주는 줄만 변경을 시켜주면 된다. 이러한 점 때문에 연결리스트는 동적으로 작동하여 공간에 낭비가 줄어든다. 이러한 **공간을 컴퓨터 용어로 노드**라고 부른다. 연결 리스트는 노드들의 집합이고 노드들은 메모리의 어떤 위치에나 있을 수 있다. 노드는 **데이터 필드와 링크 필드**로 구성되어 있다. 데이터 필드에는 우리가 넣을 데이터가 들어가 있고 링크 필드에는 다른 노드를 가리키는 포인터가 들어가있다. 우리는 링크 필드의 포인터를 통하여 다음 노드로 접근한다. 노드들은 메모리의 어디에나 있을 수 있기 때문에 연결적인 기억 공간이 없어도 데이터를 저장하는 것이 가능하고 미리 공간을 확보 할 필요가 없다. 이러한 점 때문에 오히려 데이터 조회에 단점으로 적용된다. 연결 리스트는 **단순. 원형, 이중**으로 3가지 연결 리스트가 있다.

### 스택

스택은 후입 선출(LIFO) 형식으로 입출력이 일어나는 자료 구조이다. 스택은 push, pop, peek, inEmpty가 있으며 push는 비어있는 스택에 데이터가 쌓이고 pop은 가장 위에 있는 데이터가 삭제된다. 데이터가 가득 찬 상태로 push하거나 pop 연산 중 데이터가 없으면 오류가 발생한다. peek 연산은 삭제하지 않고 보기만 하는 연산이다. 스**택은 출력 순서가 입력 순서의 역순으로 이루어져야 할 경우**에 사용 되는 자료 구조이다. 스택에서는 push(), pop() 연산을 사용하기 전에 isEmpty 등의 검사 함수를 사용하여 크기를 검사해야한다. 스택의 유명한 알고리즘으로는 괄호검사가 있다. 괄호검사는 가장 가까운 거리에 있는 괄호들끼리 서로 쌍을 이루어야 한다는 것을 알 수 있다. 그리하여 오른쪽 괄호들이 나오면 최근에 나오 왼쪽 괄호를 꺼내어 타입을 맞추어보면 쉽게 괄호들의 오류를 검사 할 수 있다.

### 스택 - 후위 표기법

후위 표기법도 대표적인 스택이다. 우리들은 평소에 중위 연산자를 이용해서 계산을 하지만 컴파일러는 괄호가 없기 때문에 후위 표기법를 선호한다. 중위 표기법 (1+2)*7의 경우 후위 표기법으로 바꾸면 12+7*이다. 피연산자의 경우 push. 연산자를 마주치면 pop() pop()을 하여 피연산자끼리 계산 후 push()를 하면서 진행한다. 후위 연산자의 경우 우선 순위가 중요한데 괄호나 \* / 등이 있다. 괄호의 경우 괄호가 끝나는 지점을 만나면 안에 있는 왼쪽 괄호가 삭제 될 때 까지 pop()을 한다.

### 스택 - 미로 탐색

미로탐색의 경우에도 Stack이 자주 사용된다.미로 탐색의 기본 방법은 시행 착오 방법이다. 한 번 시도해보고 안 되면 다시 다른 경로를 시도하는 것이다. 미로찾기에서 중요한 것은 현재의 경로가 아닐 경우 다른 경로를 선택해야 하는데 가능한 **경로 중 가장 가까운 경로가 저장되는게 좋다**. 그러므로 자료구조는 가장 최근에 저장한 경로가 쉽게 추출되는 자료구조를 사용해야하고 따라서 스택이 자연스럽게 후보가 된다. 구체적으로 현재 위치에서 갈 수 있는 칸들의 좌표를 스택에 기억했다가 막다른 길을 만나면 다시 돌아가서 새로운 경로를 찾는 것이다.

### 큐

큐는 먼저 들어온 데이터가 먼저 나가는 선입 선출(FIFO) 방식이다. 큐는 뒤에서 데이터가 추가되고 앞에서 데이터가 하나씩 삭제되는 구조를 가지고 있다. 스택과 다른점은 스택은 삽입과 삭제가 같은 쪽에서 일어나지만, 큐에선 삽입과 삭제가 다른 쪽으로 일어난다. 운영 체제에서도 큐는 중요한데 CPU와 주변기기 사이에는 항상 큐가 존재한다. CPU - 프린트 사이로 보면 CPU는 항상 빠르기 때문에 CPU로 인쇄 데이터를 만들고 인쇄 작업큐에 저장하고 다른 작업으로 넘어간다.

기본적인 배열 큐는 선형 큐의 구조이고 여기서 데이터를 증가시키고 삭제하는 과정에서 데이터 값들이 당겨지지 않아 언젠가 배열의 끝에 도달하게 된다. 이러한 단점을 보완하기 위해 원형 큐가 존재한다. 원형 큐는 처음과 끝이 연결되어있어 선형 큐의 단점을 보완 할 수 있다.

연결 리스트로 구현된 큐는 배열로 구현된 큐에 비해 크기가 제한되지 않는 장점이 있지만 코드가 좀 더 복잡해지고 링크 필드 때문에 메모리 공간이 더 많이 사용한다.

### Stack, Queue, **LinkedList vs ArrayDeque**

자바에서의 Stack 은 대부분의 조건에서 성능 저하를 일으키기 때문에 사용을 지양한다. 대신에 Deque 의 구현체를 사용한다. 일반적으로 사용하는 Deque 의 구현체는 **ArrayDeque** 과 **LinkedList** 가 있다. 둘의 차이점을 살펴보자.

덱(deque)는 double-ended queue의 줄임말로 큐의 전단과 후단에서 모두 삽입과 삭제가 가능한 큐를 의미한다.

### Deque 선언

```java
Deque que = new ArrayDeque(); //타입 설정x
Deque<DequeDemo> demo = new ArrayDeque<DequeDemo>(); //지정 타입 설정
Deque<String> deque = new ArrayDeque<String>(); // 뒷부분타입은 생략 가능

deque.addFirst("Hello"); //맨 앞에 데이터 삽입. 용량 초과시 Exception
deque.offerFirst("Hello");  //맨 앞에 데이터 삽입. 용량 초과시 false 리턴
deque.addLast("Hello"); //맨 뒤에 데이터 삽입. 용량 초과시 Exception
deque.offerLast("Hello"); //맨 뒤에 데이터 삽입. 용량 초과시 false 리턴
deque.add("Hello"); // addLast()와 동일

// remove와 poll은 deque이 비어있다면 Exception, null을 리턴하는 차이점이 있다.

deque.removeFirst(); // 첫 번째 삭제
deque.pollFirst(); // 첫 번째 삭제
deque.remove(); // 첫 번째 삭제
deque.poll(); // 첫 번째 삭제

deque.removeLast(); // 마지막 삭제
deque.pollLast(); // 마지막 삭제
deque.remove("World6"); // 원하는 데이터 삭제
deque.clear(); // 모두 삭제
System.out.println(deque); // 결과 출력

System.out.println(deque.size()) // 크기 구하기

System.out.println("첫 번째 값 : " + deque.getFirst() + ", " + deque.peekFirst() + ", " + deque.peek());
System.out.println("마지막 값 : " + deque.getLast() + ", " + deque.peekLast());

/* Iterator 클래스를 사용하여 값 출력 */
Iterator iter = deque.iterator();

while(iter.hasNext())
		System.out.print(iter.next() + " ");
```

## 계층구조

### 트리

선형 자료 구조가 아닌 계층적인 구조이고 계층적인 관계를 표현하고 싶은 경우 사용하는 자료 구조이다. 트리에는 뻗어나가는 가지가 있는데 가지 하나하나마다 노드라고 불린다. 가장 위에 있는 노드를 루트 노드라고 불리고 나머지 노드들은 서브 트리라고 불린다. 조상 노드를 부모 노드라고 하며 트리구조는 부모 노드 - 자식 노드의 반복으로 이루어져있다. 일반적은 트리의 구조는 데이터를 저장하는 데이터 필드와 자식 노드를 가르키는 링크 필드를 가지게 하는 것이다. 부모 노드에서 자식 노드의 개수를 차수라고 하는데 부모 노드는 자식 노드의 개수를 노드의 차수라고 한다. 이 방법의 문제는 노드의 크기가 고정되지 않는다는 것이다. 이런식으로 크기가 일정하지 않으면 프로그램은 복잡하게 된다. 그래서 이러한 점을 해결하기 위한 것이 **이진 트리**이다. 모든 노드가 2개의 서브 트리를 가지고 있는 구조이며 차수는 2 이하가 된다. 이진 트리는 정확하게 n개의 노드에서 n-1개의 간선을 가진다. 높이가 h인 이진 트리는 h < 이진트리 < 2^h-1개의 노드를 가진다.
